package lod.async;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.Method;

import sun.reflect.Reflection;

/**
 * Wrapper class for asynchronous threading. Does the work in parallel. Uses
 * {@link Reflection} to enable execution of any custom operator.
 * 
 * @author Evgeny Mitichkin
 * 
 */
public class AsyncRunnerThread extends Thread {

	private boolean isExecuting = true;
	private boolean exceptionHappened = false;
	private String exceptionMessage = "";
	private Object operationResult = null;
	private boolean mIsException = false;

	private Class executableClass = null;
	private String execMethodName = "";
	private Class[] mParameterTypes = null;
	private Object[] mMethodParams = null;
	private Object mInstance = null;

	Method mExecutableMethod = null;

	public synchronized boolean isException() {
		return mIsException;
	}

	/**
	 * 
	 * @param execClass
	 *            Class that contains the method wanted.
	 * @param methodName
	 *            Name of the method to be executed.
	 * @param parameterTypes
	 *            Array of input parameter types of the method that is going to
	 *            be executed.
	 * @param methodParams
	 *            Array of input parameter values of the method that is going to
	 *            be executed.
	 * @param instance
	 *            The object the underlying method is invoked from.
	 */
	public AsyncRunnerThread(Class execClass, String methodName,
			Class[] parameterTypes, Object[] methodParams, Object instance) {
		this.executableClass = execClass;
		this.execMethodName = methodName;
		this.mParameterTypes = parameterTypes;
		this.mMethodParams = methodParams;
		this.mInstance = instance;
		try {
			Method[] methodInfos = executableClass.getDeclaredMethods();
			mExecutableMethod = executableClass.getDeclaredMethod(
					execMethodName, mParameterTypes);
		} catch (NoSuchMethodException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (SecurityException e) {
			// TODO: handle exception
		}
	}

	/**
	 * Determines if the asynchronous process is still executing
	 * 
	 * @return {@link boolean} flag
	 */
	public synchronized boolean isRunnerExecuting() {
		return isExecuting;
	}

	/**
	 * Determines if an exception happened during the execution.
	 * 
	 * @return {@link boolean} flag
	 */
	public synchronized boolean isExceptionHappened() {
		return exceptionHappened;
	}

	/**
	 * Returns an exception message generated by exception handler
	 * 
	 * @return {@link String} exception message
	 */
	public synchronized String getexceptionMessage() {
		return exceptionMessage;
	}

	/**
	 * Returns the result of asynchronous operation.
	 * 
	 * @return {@link Object} result
	 */
	public synchronized Object getOperationResult() {
		return operationResult;
	}

	/**
	 * Sets the result of asynchronous operation to null
	 */
	public synchronized void setOperationResultNull() {
		this.operationResult = null;
	}

	@Override
	public void run() {
		isExecuting = true;
		try {
			operationResult = mExecutableMethod
					.invoke(mInstance, mMethodParams);
			isExecuting = false;
		} catch (Exception e) {

			StringWriter sw = new StringWriter();
			PrintWriter pw = new PrintWriter(sw);
			e.printStackTrace(pw);

			exceptionMessage = sw.toString();
			e.printStackTrace();
			mIsException = true;
			isExecuting = false;
		}
	}
}
